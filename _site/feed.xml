<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-07T11:23:52-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gecko05 Blog</title><subtitle>Blog entries for personal projects ranging from low level programming to simple games.</subtitle><entry><title type="html">Making your first emulator Part I</title><link href="http://localhost:4000/2022/10/22/first-emulator-part1.html" rel="alternate" type="text/html" title="Making your first emulator Part I" /><published>2022-10-22T00:00:00-05:00</published><updated>2022-10-22T00:00:00-05:00</updated><id>http://localhost:4000/2022/10/22/first-emulator-part1</id><content type="html" xml:base="http://localhost:4000/2022/10/22/first-emulator-part1.html">&lt;p&gt;I decided to make these posts to walk you through the process of creating a simple emulator for a simple processor: &lt;a href=&quot;https://www.amazon.com/Computer-architecture-science-Caxton-Foster/dp/B0006C2T2O&quot;&gt;1970 Caxton C. Foster’s Blue&lt;/a&gt;.
Think of this tutorial as a way to give you ideas on how to write an emulator, when I started writing this I knew emulators existed and I was familiar with programming, but I just didn’t know where to begin. So if you feel like how I felt, I hope this post can help you and make things more clear.&lt;/p&gt;

&lt;p&gt;We’re going to code an emulator in C++, but the approach used here can be applied to any language, some familiarity with computer architecture concepts and of course programming may be needed to follow this post.&lt;/p&gt;

&lt;h2 id=&quot;blues-architecture&quot;&gt;Blue’s architecture&lt;/h2&gt;

&lt;p&gt;Blue is a simple and underpowered machine, but it still reflects the core concept of how computers work. In order to 
write something that will ressemble the original hardware, we first need to know the innards of the design.&lt;/p&gt;

&lt;p&gt;These are the specs:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;4096 words of addressed core storage of 16 bits per word.&lt;/li&gt;
  &lt;li&gt;Words in data storage as treated as 15-bit integers plus sign.&lt;/li&gt;
  &lt;li&gt;Instructions are 4 bit OP code with 12 bit address (4096).&lt;/li&gt;
  &lt;li&gt;16-bit Acc.&lt;/li&gt;
  &lt;li&gt;16-bit instruction register.&lt;/li&gt;
  &lt;li&gt;12-bit program counter.&lt;/li&gt;
  &lt;li&gt;12-bit Memory Address Register, 16-bit Memory Buffer Register and a 16-bit Z register that are not accessible to the programmer.&lt;/li&gt;
  &lt;li&gt;16 different instructions for the 4-bit OPCode.&lt;/li&gt;
  &lt;li&gt;Two’s complement interpretation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And here’s the instruction set:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Octal representation for Op code&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;00-HLT XXXX&lt;/strong&gt;: The computer will halt. The START button on the console will cause the computer to start going again, beginning with the instruction following the HLT.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;01-ADD XXXX&lt;/strong&gt;: The contents of XXXX are added tot the contents of the accumulator and the sum is put into the accumulator. If the result is greater than 2^15-1 or less than -2^15 the machine stops.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;02-XOR XXXX&lt;/strong&gt;: Exclusive OR of the contents of XXXX and Acc replace Acc.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;03-AND XXXX&lt;/strong&gt;: AND between address and Acc, replace Acc.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;04-IOR XXXX&lt;/strong&gt;: OR&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;05-NOT XXXX&lt;/strong&gt;: Acc is inverted&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;06-LDA XXXX&lt;/strong&gt;: Loads addresss into the Acc.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;07-STA XXXX&lt;/strong&gt;: Acc is copied to Address. Acc remains unchanged.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;10-SRJ XXXX&lt;/strong&gt;: Contents of program counter(present instruction location plus one) are ORed into 12 Acc bits. XXXX is copied into the program counter, used to jump.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;11-JMA XXXX&lt;/strong&gt;: If the sign bit of the Acc is one, the number XXXX is placed in the program counter. Else, does nothing.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;12-JMP XXXX&lt;/strong&gt;: Jumps to address XXXX&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;13-INP XXYY&lt;/strong&gt;: Upper 8 bits of the Acc are cleared and the next 8-bit character from input device YY is entered into the low end of Acc. The XX part of the field is ignored. Blocks until transfer is complete.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;14-OUT XXYY&lt;/strong&gt;: The upper 8 bits of the Acc are sent to output device YY. The XX is ignored. Blocks until the device accepts data.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;15-RAL XXXX&lt;/strong&gt;: Acc is rotated left one place.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;16-CSA XXXX&lt;/strong&gt;: The number set into the console switch register replaces the contents of the accumulator.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;17-NOP XXXX&lt;/strong&gt;: Does nothing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, the real implementation innards are kinda complicated, we have tons of logic gates and buses inside Blue,  you can check &lt;a href=&quot;https://github.com/Gecko05/BlueFPGA&quot;&gt;this repo&lt;/a&gt; for more details. This makes the task of writing a hardware emulator much more complicated than writing a software emulator, at least a software emulator that only cares about interpreting programs and outputs. You can read about my attempt of a &lt;a href=&quot;https://gecko05.github.io/2021/10/07/fpga-computer.html&quot;&gt;failed hardware emulator here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For this exercise, we don’t really care about implementing all the buses and gate logic, we’re only worried about handling the registers properly
and following what the specification tells us about how each instruction is interpreted.&lt;/p&gt;

&lt;h2 id=&quot;emulating-our-first-cycle&quot;&gt;Emulating our first cycle&lt;/h2&gt;

&lt;p&gt;Let’s start with the simple stuff. We’ll forget about any input/output handling and start by coding the core of our emulator, the function
that will emulate the instruction cycle. That is, covering the steps that will be needed to process a whole instruction. We’ll begin by emulating the FETCH cycle.&lt;/p&gt;

&lt;p&gt;Each cycle is made of 8 smaller steps, each step’s timing is defined by a clock and 8 lines that represent each of the steps. Every time Blue’s clock ticks, a line is set to HIGH and the others to LOW, this can be easily represented by a counter variable that increments from 1 to 8 and then it’s reset back to 1.&lt;/p&gt;

&lt;p&gt;So, our emulated cycle will look as follows:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uint8_t clock_pulse = 1;

void emulateCycle()
{
	while (clock_pulse &amp;lt; 9)
	{
		process_tick(clock_pulse);
		clock_pulse++;
	}
	clock_pulse = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;As you can see a major cycle will consist of a loop of 8 smaller steps, each iteration we’ll call &lt;em&gt;process_tick&lt;/em&gt; to execute any step defined by our instruction. Each instruction does different things at each step of the cycle and both cycles are made of 8 steps, so we can leave all the implementation details of FETCH/EXECUTE to this &lt;em&gt;process_tick&lt;/em&gt; function.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/Gecko05/BlueFPGA/raw/master/resources/028bd53753d54035b12f278d878513ba.png&quot; alt=&quot;Fetch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, let’s start fleshing out some of the instructions. These are the common steps that we need to emulate for any instruction as long as the fetch cycle is active. Some instructions only need this cycle, while others need more steps and thus require an additional EXECUTE cycle.
To achieve this, first we have to define some registers. All the registers are 16-bit wide, so uint16_t can be used as the type.&lt;/p&gt;

&lt;p&gt;These are all the registers and RAM we’ll ever need for this implementation:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define RAM_LENGTH 4096
uint16_t RAM[RAM_LENGTH];

typedef uint16_t blue_register;
blue_register A;         // Accumulator - For arithmetics, calculations
blue_register DIL;       // Data-In - To receive input data
blue_register DOL;       // Data-Out - To output data
blue_register DSL;       // Device Selector - To select IO device
blue_register IR;        // Instruction Register - Stores the current instruction and it&apos;s operands
blue_register MAR;       // Memory Address Register - Tells us which RAM address to read
blue_register MBR;       // Memory Buffer Register - Actual RAM contents as pointed by MAR
blue_register PC = 0x00; // Program Counter - To perform jumps and handle instruction numbers
blue_register SR;        // Console Switch Register - To input data manually
blue_register Z;         // Z register - Auxiliary register for calculations
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I went a bit too fancy with the typedef instead of using plain uint16_t, but that’s totally optional. I just thought it would be more readable that way.&lt;/p&gt;

&lt;p&gt;Inside &lt;em&gt;process_tick&lt;/em&gt; we’ll code the logic for executing the common steps for FETCH cycles. So we also need to define the states and a variable to hold the current state.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef enum {
	EXECUTE,
	FETCH,
} State;

State STATE = FETCH;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now let’s code the common steps.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void process_tick(uint8_t tick)
{
	switch (tick) {
	case 1:
		break;
	case 2:
		if (STATE == FETCH)
			PC += 1;
		break;
	case 3:
		if (STATE == FETCH)
			MBR = 0x00;
		break;
	case 4:
		if (STATE == FETCH) {
			IR = 0x00;
			MBR = RAM[MAR]; // The Clear in step 4 also means updating MBR in the next step
		}
		break;
	case 5:
		if (STATE == FETCH)
			IR = MBR;
		break;
	case 6:
		break;
	case 7:
		break;
	case 8:
		break;
	default:
		break;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You’ll notice that we’re missing the part where the Memory Address Register is updated based on the Program Counter, without this, we’re stuck executing the same instruction again and again. However, this is a instruction-specific operation, so we need to start implementing the actual instructions if we want to advance through our program.&lt;/p&gt;

&lt;h2 id=&quot;emulating-the-nop-instruction&quot;&gt;Emulating the NOP instruction&lt;/h2&gt;

&lt;p&gt;Let’s implement the easiest instruction first, the NOP instruction.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/Gecko05/BlueFPGA/raw/master/resources/9887f70e74ef4431b4aebd180116f503.png&quot; alt=&quot;NOP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;According to the spec, the NOP instruction does nothing when executed, so we only need to care about updating the MAR with the contents of the Program Counter so that the next instruction is executed after we’re done with NOP. This is the code we’ll need:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void do_NOP(uint8_t tick)
{
	if (tick == 8)
		MAR = PC;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Basically, if we’re at step 8, we’ll just update the MAR. Now let’s attach it to our &lt;em&gt;process_tick&lt;/em&gt; function. First we define a function to help us know the number of the instruction we’re processing. For example, NOP is instruction number 15 in decimal, 0F in hexadecimal or 17 in octal.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uint8_t get_instruction()
{
	return ((IR &amp;amp; 0xF000) &amp;gt;&amp;gt; 12);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now let’s use it in an if statement to execute our instruction. To do so, we’ll modify &lt;em&gt;process_tick&lt;/em&gt; as follows:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void process_tick(uint8_t tick)
{
	...

	case 7:
		break;
	default:
		break;
	}
	uint8_t INS = get_instruction();
	if (INS == 15) {
		do_NOP(tick);
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;There are better, more maintainable ways of doing this other than a bunch of if/else statements for every instruction. We’ll see that in the next post once we start introducing more instructions, or you can just take a peek at the emulator’s repo ;).&lt;/p&gt;

&lt;p&gt;Now, let’s code the “infrastructure” we need to load a program and run it inside our emulator!
Time to see the matrix! Our test program will be just a bunch of NOP instructions with random operands as you can &lt;em&gt;clearly&lt;/em&gt; see. What we’ll use a test program is basically just machine code, we’re writing the instructions by hand using hexadecimal numbers. There’s an opportunity to create an assembler program that lets us write in “assembly” instead of plain numbers, but we’ll cover that later.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/matrix.png&quot; alt=&quot;See the matrix&quot; width=&quot;400px&quot; /&gt;
    &lt;figcaption&gt;Ah yes, that&apos;s a woman in a red dress&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;NOP takes no operands so their presence shouldn’t really affect the instruction, they’ll simply be ignored.
The test program:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// The first nibble of the most significant byte holds the
// instruction. The rest is just operands.
// F0 03 means NOP with a 3 as an operand
// 17 00 03 in Octal

// Sample program
uint16_t program0[4] = {
	0xF000, // NOP 000
	0xF003, // NOP 003
	0xF000, // NOP 000
	0xF005  // NOP 005
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We now need a way to load the program into the RAM and actually execute it.
This will run our program in an infinite loop and give us debug information about the registers on every cycle:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dumpRegisters()
{
	printf(&quot;PC: %04x A: %04x IR: %04x Z: %04x MAR: %04x MBR: %04x DSL: %02x DIL: %02x DOL: %02x\n&quot;, PC, A, IR, Z, MAR, MBR, (DSL &amp;amp; 0x00FF), (DIL &amp;amp; 0x00FF), (DOL &amp;amp; 0x00FF));
}

void runProgram(const uint16_t* program)
{
	std::cout &amp;lt;&amp;lt; &quot;Copying program to the RAM\n&quot;;
	memset(RAM, 0x00, RAM_LENGTH * sizeof(uint16_t));
	memmove(RAM, program, (RAM_LENGTH * sizeof(uint16_t)));
	for (;;) {
		emulateCycle();
		dumpRegisters();
	}
}

int main(int argc, char* argv[])
{
	runProgram(program0);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We can do all sort of quality of life additions at this point, for example, in the original repo I coded some sort of gdb replica to step instruction by instruction without needing to actually debug the emulator. But I guess I’ll leave this for later once the instructions start to get more complicated.&lt;/p&gt;

&lt;p&gt;Time to see our emulator in action. Compile it with g++ or any C++ compiler you have available and run the executable!&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/emulatorOutput.png&quot; alt=&quot;Emulator Output&quot; width=&quot;700px&quot; /&gt;
    &lt;figcaption&gt;Humble beginnings&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Even though this doesn’t look too impressive, it’s exciting enough! From the output you can see how the contents of the Memory Buffer Register, Instruction Register, Memory Address Register and Program Counter change with each cycle. Although the NOP instruction does nothing, we can be sure that the instructions are being read from the RAM and the PC has an effect on the MAR.&lt;/p&gt;

&lt;h2 id=&quot;emulating-the-jmp-instruction&quot;&gt;Emulating the JMP instruction&lt;/h2&gt;

&lt;p&gt;To spice things up let’s implement the JMP instruction.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/jumpIns.png&quot; alt=&quot;Jump Instruction&quot; width=&quot;250px&quot; /&gt;
    &lt;figcaption&gt;Look ma, jumping is so simple!&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void do_JMP(uint8_t tick)
{
	if (tick == 6) {
		PC = 0;
	} else if (tick == 7) {
		PC = (IR &amp;amp; 0x0FFF);
	} else if (tick == 8) {
		MAR = PC;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is a fun instruction that will let us jump around the code, allowing us to create all sorts of loops in our code. Now, let’s add it to our &lt;em&gt;process_tick&lt;/em&gt; routine.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void process_tick(uint8_t tick)
{
    ...
	uint8_t INS = get_instruction();
	if (INS == 15) {
		do_NOP(tick);
	}
	else if (INS == 10) {
		do_JMP(tick);
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finally, we change our program to include some jump instructions, compile and run the emulator!&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Sample program
uint16_t program0[6] = {
	0xF000, // Instruction #0
	0xF003,
	0xA004, // Jump to instruction #4 (fifth one)
	0xF005, // This shouldn&apos;t be executed
	0xF010,
	0xA000 // Jump back to instruction #0
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This program should skip 0xF005 and jump into 0xF010, then jump back to the beginning looping infinitely. Let’s verify it works with our debug information.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/blueLoop.png&quot; alt=&quot;Blue loop&quot; width=&quot;700px&quot; /&gt;
    &lt;figcaption&gt;It just works&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Finally some tasty instructions! As you can see, we’re jumping twice, the first jump will skip instruction 0xF005, then the second jump loops us back to the first instruction 0xF000.&lt;/p&gt;

&lt;p&gt;The end result for this part should look something like &lt;a href=&quot;https://github.com/Gecko05/gecko05.github.io/tree/master/assets/blueEmulator.cpp&quot;&gt;this&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;to-be-continued&quot;&gt;To be continued…&lt;/h2&gt;

&lt;p&gt;Extending the emulator and adding more instructions will start making our program harder to debug and modify. In the next part of this tutorial we’ll go through the process of adding more instructions to our emulator and making things a little bit more maintainable. We’ll also eventually reach the part where we need to handle IO data, and there are a ton of ways to tackle this topic.&lt;/p&gt;

&lt;p&gt;Take a look at the &lt;a href=&quot;https://github.com/Gecko05/BlueFPGA/tree/master/SoftBlue&quot;&gt;finished emulator&lt;/a&gt; or continue fleshing out your emulator in any way you want. You could even define new instruction sets, create a pipeline, change the RAM size, etc. Sky is the limit!&lt;/p&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">I decided to make these posts to walk you through the process of creating a simple emulator for a simple processor: 1970 Caxton C. Foster’s Blue. Think of this tutorial as a way to give you ideas on how to write an emulator, when I started writing this I knew emulators existed and I was familiar with programming, but I just didn’t know where to begin. So if you feel like how I felt, I hope this post can help you and make things more clear.</summary></entry><entry><title type="html">Developing a computer inside an FPGA</title><link href="http://localhost:4000/2021/10/07/fpga-computer.html" rel="alternate" type="text/html" title="Developing a computer inside an FPGA" /><published>2021-10-07T00:00:00-05:00</published><updated>2021-10-07T00:00:00-05:00</updated><id>http://localhost:4000/2021/10/07/fpga-computer</id><content type="html" xml:base="http://localhost:4000/2021/10/07/fpga-computer.html">&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
A little more than a year ago I started working (on and off) on a new project to improve my understanding of computer architecture and VHDL programming. I&apos;ve not always been interested in using FPGAs and unfortunately, at university I didn&apos;t quite grasp the purpose of FPGA programming. 
&lt;/p&gt;&lt;p&gt;
As I started learning more about low level programming and videogames, I came up with the idea of developing an emulator for the NES inside an FPGA to play on the &quot;original&quot; hardware withouth having to find and maintain one. However, my computer architecture and VHDL skills at the time were almost non-existent, so I decided to start with a simpler project.
&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;/assets/images/nes_console.jpg&quot; alt=&quot;NES&quot; width=&quot;500px&quot; /&gt;
    &lt;figcaption&gt;Man, I wish that my dad hadn&apos;t thrown away my NES&lt;/figcaption&gt;
&lt;/figure&gt; 
&lt;p&gt;
After searching for projects, I came across &lt;a href=&quot;https://hackaday.com/2016/03/16/crawl-walk-run-planning-your-first-cpu-design/&quot;&gt;this article&lt;/a&gt; from Al Williams on &lt;a href=&quot;https://hackaday.com&quot;&gt;Hackaday&lt;/a&gt;. Al suggested starting with a basic computer (BLUE), one that Caxton C. Foster specified in his book &quot;Computer Architecture&quot;. I was unable to find this book physically at an affordable price, but eventually I found a borrowable version on &lt;a href=&quot;https://archive.org&quot;&gt;archive.org&lt;/a&gt;, I love this site! 
&lt;/p&gt;&lt;p&gt;
I created &lt;a href=&quot;https://github.com/Gecko05/BlueFPGA&quot;&gt;this repository&lt;/a&gt; and started translating the simplest parts of the logic gate diagrams to VHDL programs. Sites like &lt;a href=&quot;https://nandland.com&quot;&gt;nandland.com&lt;/a&gt; and &lt;a href=&quot;https://vhdlwhiz.com&quot;&gt;vhdlwhiz.com&lt;/a&gt; have been especially helpful in teaching me the basics of VHDL development and getting me ready to write this project.
&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&quot;reinventing-the-wheel&quot;&gt;Reinventing the wheel&lt;/h2&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
The first thing I did was read through the specification and writing down notes on how the computer really works. There are a lot of nice diagramas and tables which I copied into the repositories README file to keep the important stuff accessible and organized. 
&lt;/p&gt;&lt;/div&gt;
&lt;h4 id=&quot;some-relevant-info-about-blue&quot;&gt;Some relevant info about BLUE&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4096 words of addressed core storage of 16 bits per word.&lt;/li&gt;
  &lt;li&gt;Words in data storage as treated as 15-bit integers plus sign.&lt;/li&gt;
  &lt;li&gt;Instructions are 4 bit OP code with 12 bit address (4096).&lt;/li&gt;
  &lt;li&gt;16-bit Acc.&lt;/li&gt;
  &lt;li&gt;16-bit instruction register.&lt;/li&gt;
  &lt;li&gt;12-bit program counter.&lt;/li&gt;
  &lt;li&gt;12-bit Memory Address Register, 16-bit Memory Buffer Register and a 16-bit Z register that are not accessible to the programmer.&lt;/li&gt;
  &lt;li&gt;16 different instructions for the 4-bit OPCode.&lt;/li&gt;
  &lt;li&gt;If the highest bit is 1, the number is negative.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/instruction_tree.png&quot; alt=&quot;Instruction tree&quot; width=&quot;200px&quot; /&gt;
    &lt;figcaption&gt;Ha! Was it really that simple?&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
As you can see BLUE is a really simple computer, perfect for beginners in computer architecture. To be honest, I wasn&apos;t expecting things inside a computer to be as simple as they are, with a bunch of logic diagrams, we&apos;re able to build complex units that handle rather abstact tasks like arithmetic operations.
&lt;/p&gt;&lt;p&gt;
At this point, my motivation peaked and I started to get a lot of &quot;aha!&quot; moments, I thought everything was sorted out for me inside these logic diagrams and I was ready to jump into the code and start programming.
&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&quot;morning-stiffness&quot;&gt;Morning stiffness&lt;/h2&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
As always, setting up the tools and stuff you need to actually do the coding can be really tedious. For this project I ordered an FPGA from Numato, specifically, the &lt;a href=&quot;https://numato.com/product/mimas-v2-spartan-6-fpga-development-board-with-ddr-sdram/&quot;&gt;MimasV2&lt;/a&gt;. It comes with a nice board full of IO components to test your designs and has worked really well so far. I can&apos;t tell yet if this board is enough to support a full NES emulator though. One of the struggles I faced was setting up the software I needed to write the code, flash the FPGA and also sort out how things worked overall. It had been a while since I last used Xilinx ISE, and I had never used it before on a Linux machine. 
&lt;/p&gt;&lt;/div&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://numato.com/wp-content/uploads/2020/08/MimasV2_2-2-1.png&quot; alt=&quot;MimasV2&quot; width=&quot;500px&quot; /&gt;
    &lt;figcaption&gt;Aesthetic, isn&apos;t it?&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div style=&quot;text-align: justify&quot;&gt;
&lt;p&gt;
Once I got ISE ready to go, I tried to figure out how to actually flash the FPGA with the binary file that is generated from the VHDL code. At first I tried to run a Python utility &quot;provided&quot; by Numato to flash their devices, but I just couldn&apos;t get it running. The best tool to flash the FPGA runs only on Windows, so after giving up on the Linux tool I decided to try and run the Windows tool using Wine, it worked like a charm.
&lt;/p&gt;&lt;p&gt;
After doing a few beginner level FPGA projects, I felt ready to jump into programming a clock module for BLUE.
&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&quot;working-as-a-translator&quot;&gt;Working as a translator&lt;/h2&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;&lt;p&gt;
While I was programming the clock module, I started to notice things wouldn&apos;t be as straightforward as copying all the logic gate diagrams to VHDL statements, or at least, that wouldn&apos;t be the easiest way to do it. I wanted to have a middleground between copying exactly the diagrams I found and simplifying things to better fit with VHDL statements.
&lt;/p&gt;&lt;p&gt;
From what I can gather, the clock module of BLUE is a bit unconventional, even the author suggests doing things in a different way. The important stuff is that a cycle in BLUE is made of 8 clock steps, there&apos;s a signal for each step which will be used to define what needs to be done for each instruction.
&lt;/p&gt;&lt;/div&gt;

&lt;figure&gt;
    &lt;img src=&quot;/assets/images/steps.png&quot; alt=&quot;InstructionSteps&quot; width=&quot;500px&quot; /&gt;
    &lt;figcaption&gt;Just need a bunch of if statements&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;&lt;p&gt;
The clock for BLUE in VHDL is basically a process loop that at a set minor frequency (50 MHz) rotates a bit on the clock steps signal. You could think of it as a semaphore with 8 lights that takes 0.16 micro seconds to go through all the lights, that&apos;s fast!
&lt;/p&gt;&lt;p&gt;
I wanted to start with the simpler instructions for this project, so the first step was coding all the necessary stuff to get the NOP, HALT, and JUMP instructions ready. 
&lt;/p&gt;&lt;p&gt;
As soon as I finished programming registers like the Memory Buffer Register, Memory Address Register and Program Counter, I began programming what I call the Control Unit, although I&apos;m not entirely sure if this is the right term. The Control Unit would be the part that orchestrates the interactions between all the registers, instructions and power options. Currently in my code this part of BLUE is a mess, there are too many lines of code for my test and I&apos;m sure there&apos;s a way to isolate things a little better, especially the instructions decoding part.
&lt;/p&gt;&lt;/div&gt;
&lt;figure&gt;
    &lt;img src=&quot;/assets/images/buses.png&quot; alt=&quot;Buses&quot; width=&quot;500px&quot; /&gt;
    &lt;figcaption&gt;It turns out I can&apos;t just program these buses&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div style=&quot;text-align: justify&quot;&gt;&lt;p&gt;
When I began programming the CU, I noticed I wouldn&apos;t be able to actually program a Bus that connects between several registers as described in the book, at least not with my current skill level. I searched around the web on how to program such thing, but a lot of people seemed to advice towards using multiplexing instead of actually programming buses, so I followed this advice.
&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&quot;not-quite-there-yet&quot;&gt;Not quite there yet&lt;/h2&gt;

&lt;div style=&quot;text-align: justify&quot;&gt;&lt;p&gt;
After a lot of struggle and almost 45 hours of free time later, I had this basic &quot;computer&quot; that could interpret NOP, HALT, and JUMP instructions! It ain&apos;t much, but it&apos;s honest work.
&lt;/p&gt;&lt;p&gt;
Currently, my BLUE implementation is also able to process store/load and arithmetic instructions, I started coding the ALU and two different states for double cycle instructions like ADD. I&apos;ve learned a lot about VHDL along the way and I wish to finish coding BLUE, however, there are some challenges I need to tackle first. As I start adding more instructions, debugging becomes more and more complicated, those signal diagrams from the simulations are a bit confusing and I wonder what other ways exist to debug the whole thing. 
&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;/assets/images/graphs.png&quot; alt=&quot;Difficult graphs&quot; width=&quot;500px&quot; /&gt;
    &lt;figcaption&gt;Okay this used to be way easier when I had only 4 instructions&lt;/figcaption&gt;
&lt;/figure&gt; 
&lt;p&gt;
In order to ease things in the future, I plan on adding a debugging feature to dump the content of the RAM and each individual register via serial communication, and then arrange that data in some sort of user interface. This should help me debug programs and the actual behavior of the computer. Additionally I&apos;m also working on writing a C++ software emulator, which I&apos;ll describe in a later post, which is surprisingly easier to implement than the actual VHDL thing.
&lt;/p&gt;&lt;p&gt;
Feel free to use the project&apos;s repository as you wish, this is a learning exercise I really recommend doing to anyone interested in basic computer architecture and FPGAs. I&apos;m still far away from my actual goal of coding a hardware emulator for the NES, but it&apos;s been a really fun project to do so far and hopefully I&apos;ll be able to finish it soon. Also I started taking this course by the LinuxFoundationX that teaches how to program a RISC V processor, haven&apos;t finished it yet, but it seems to be a good way to start with computer architecture: &lt;a href=&quot;https://www.edx.org/course/building-a-risc-v-cpu-core&quot;&gt;https://www.edx.org/course/building-a-risc-v-cpu-core&lt;/a&gt;
&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Gecko05/BlueFPGA&quot;&gt;Code repository&lt;/a&gt;&lt;/p&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">A little more than a year ago I started working (on and off) on a new project to improve my understanding of computer architecture and VHDL programming. I&apos;ve not always been interested in using FPGAs and unfortunately, at university I didn&apos;t quite grasp the purpose of FPGA programming. As I started learning more about low level programming and videogames, I came up with the idea of developing an emulator for the NES inside an FPGA to play on the &quot;original&quot; hardware withouth having to find and maintain one. However, my computer architecture and VHDL skills at the time were almost non-existent, so I decided to start with a simpler project. Man, I wish that my dad hadn&apos;t thrown away my NES After searching for projects, I came across this article from Al Williams on Hackaday. Al suggested starting with a basic computer (BLUE), one that Caxton C. Foster specified in his book &quot;Computer Architecture&quot;. I was unable to find this book physically at an affordable price, but eventually I found a borrowable version on archive.org, I love this site! I created this repository and started translating the simplest parts of the logic gate diagrams to VHDL programs. Sites like nandland.com and vhdlwhiz.com have been especially helpful in teaching me the basics of VHDL development and getting me ready to write this project.</summary></entry><entry><title type="html">Gauss Synth - Puzzle game in Pico8</title><link href="http://localhost:4000/2020/03/31/gauss-synth.html" rel="alternate" type="text/html" title="Gauss Synth - Puzzle game in Pico8" /><published>2020-03-31T00:00:00-06:00</published><updated>2020-03-31T00:00:00-06:00</updated><id>http://localhost:4000/2020/03/31/gauss-synth</id><content type="html" xml:base="http://localhost:4000/2020/03/31/gauss-synth.html">&lt;iframe src=&quot;https://www.lexaloffle.com/bbs/widget.php?pid=gaussynth&quot; allowfullscreen=&quot;&quot; width=&quot;621&quot; height=&quot;513&quot; style=&quot;border:none; overflow:hidden&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;This is a simple puzzle game made in Pico8. Inspired by Gauss Jordan elimination.&lt;/p&gt;

&lt;p&gt;My objective was to reflect the “intuitive” feeling of solving systems of equations using the GJ elimination method in a simpler and more fun way. I’m not sure how fun it is though, to be honest I don’t feel the desire to play it much.&lt;/p&gt;

&lt;p&gt;Controls:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Pressing Z will change the colors of the selected row.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pressing right, will allow you to swap the selected row into another position.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pressing left, will duplicate the selected row to allow you merging it with another row. You can press Z to change the colors of the duplicated row as well.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jaime Centeno</name></author><summary type="html"></summary></entry><entry><title type="html">Poland’s cozy cold</title><link href="http://localhost:4000/2020/02/15/cozy-cold-Poland.html" rel="alternate" type="text/html" title="Poland’s cozy cold" /><published>2020-02-15T00:00:00-06:00</published><updated>2020-02-15T00:00:00-06:00</updated><id>http://localhost:4000/2020/02/15/cozy-cold-Poland</id><content type="html" xml:base="http://localhost:4000/2020/02/15/cozy-cold-Poland.html">&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;
Last December I made my first trip ever to a new country: Poland. This was also my first time taking a flight and my first time taking vacations after I started working as a developer. I decided to go alone on a trip to the city of Poznan, capital of the Greater Poland.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ratusz.jpeg&quot; alt=&quot;Ratusz&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;why-poland&quot;&gt;Why Poland?&lt;/h2&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; &lt;p&gt;
When I say I want to visit Poland, this is the first question I get from almost every Pole I&apos;ve talked to: &quot;Whyyy?&quot;. Sometimes I feel like Poles imply that their country is neither a beautiful nor an interesting place to visit compared to the rest of the world, or to the rest of Europe, which of course isn&apos;t true.&lt;/p&gt; &lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/colorPoznan.jpeg&quot; alt=&quot;Poznan&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; &lt;p&gt;
As a nerd, my first interest in Poland sparked when I started playing The Witcher games. I was amazed at how different the first game felt compared to your average fantasy RPG. Sure it&apos;s still some kind of European medieval fantasy game, but the monsters, the story, and the whole mood of the game feel like a breath of fresh air. I had to figure out where this game came from!&lt;/p&gt;

&lt;p&gt;After getting to know more about the origins of the game, and a bit about the history of Poland, I became so interested in getting to know this place even better. I started planning on visiting this country for my first vacations, which would be around December holidays so I could stay there as long as I could without having to quit my job. I waited for a year, during which I finally got to study the Polish language seriously. Although some of the words in Polish can look intimidating, like &quot;chrząszcz&quot;, it&apos;s a rather easy language to pronounce for someone from Mexico, since most of the letters have equivalent sounds in spanish, you just have to get used to pronouncing a bunch of consonants together. After almost a year of self study and a couple of months aided by my Polish teacher, I was able to handle simple and slow conversations, nothing too fancy, but something that would help me get out of trouble and connect with a few people.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/witcher.jpeg&quot; alt=&quot;Witcher&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 

&lt;p&gt;If I were to repeat this trip with my current level of Polish, I would feel more afraid than I felt before. I seriously overestimated my Polish proficiency, thinking that I would be able to understand every single word that came out of native speakers. I was not expecting to not understand people talking around me!&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;getting-to-know-the-winter&quot;&gt;Getting to know the winter&lt;/h2&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 

&lt;p&gt;As someone from a tropical birthplace, I had never really experienced a classic movie-like winter season, those ones where the trees die, the clouds are always covering the sun, and the cold can kill you if you don&apos;t wear the appropiate clothes. In my city, winter usually looks like a cool and dry summer which might sound crazy for people who live far from the equator.&lt;/p&gt;

&lt;p&gt;After almost 20 hours of traveling, I finally arrived to Poland. The first time I heard Polish I felt happy, as if I was at home. I had been hearing people talking in german for about 18 hours, and I don&apos;t know german at all. However, as I started hearing this first Polish conversation, I also started panicking a bit when I noticed I only understood around 20% of what people were saying, maybe even less! I instantly knew I could have some issues using a service, asking for food, or just trying to chat with Poles. &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/walk.jpeg&quot; alt=&quot;Walk&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;When I arrived to the airport, I saw this grey cold winter weather I&apos;ve never seen before. It was something exciting, yet also daunting. Everything was so new to me, and I felt like I was a child who got lost. Also, the airport was lonely, and a bit dark since not all the lights were turned on, it was a quiet time for tourism. No familiar faces, no native languages, everyone was so tall and white! Not that there aren&apos;t any tall or white people in Mexico, it&apos;s just that it was the fist time I didn&apos;t really fit among the crowd.&lt;/p&gt;

&lt;p&gt;It&apos;s true I could have been more comfortable going to almost anywhere else in Mexico, and even more comfortable if I just stayed at home playing games from my bed all day long. I knew I wasn&apos;t going to feel comfortable, but I wasn&apos;t sure what to expect from traveling abroad either.&lt;/p&gt;

&lt;p&gt;So then I stayed at a hostel, expecting to make new friends who would share with me a lot of interesting stories about how they travel around the world and what they like about Poland. Silly me, as I mentioned this was a quiet season for tourism and I could barely talk with Poles, ha! For the most part I stayed alone in a bedroom for six people. The first night was so cold, and I had no idea how warmers worked so I didn&apos;t bother to turn them on (Yeah, I can be that stupid). The first day I met an cool Ukrainian guy, and we talked for a while in English and then he went on his way to Ukraine to visit his family for New Year&apos;s Eve.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zamek.jpeg&quot; alt=&quot;Zamek&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 

&lt;p&gt;The next day, I started feeling sick, jetlag hit me pretty hard and amplified my anxiety, I just didn&apos;t have the energy to get up from bed and start walking around the city. The sunset happened around 3:30pm and it was too cold outside, so I felt like sleeping a lot for the first three days of my vacations, what a waste. Also I started having this weird feeling about being &quot;no one&quot; outside of Mexico, as if my enviroment dictated who I was.&lt;/p&gt;

&lt;p&gt;At the hostel, I met a Peruvian guy that just moved from Spain to Poland and enjoyed to spend his free nights at Poznan, and an old Polish guy who tried to flirt with me and complimented my brown skin for the first time, haha I didn&apos;t know I was so exotic!&lt;/p&gt;

&lt;p&gt;Then I moved out of the hostel and stayed at a hotel for the rest of my stay. On the way to the hotel I felt a bit misserable, I felt like I was wasting my vacations, in the same fashion as I felt about wasting my free time in Mexico. I had been sick with a flu and sleeping almost all day long, going out to get to know the old town just ocassionally. I started missing my family, my friends and being in a place where I would have no stress communicating with people. &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;getting-used-to-a-new-environment&quot;&gt;Getting used to a new environment&lt;/h2&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;At the hotel I got used to the hour difference and things started to look brighter for me. The breakfast at the hotel was nice, practiced talking Polish with some random people, and I got to know Poznan better. Also I met a guy from Mexico who was on vacations too, he was visiting his sister who already lived in Poland. We went out to eat some pierogi, meet a Polish friend of his, and I got to talk plenty of spanish. In the following days I would meet with my best Polish friend with whom I had been talking for almost a year now. Around this time my anxiety started to drop and something clicked on my head; I&apos;m just the same old me, and maybe even a more interesting and well-rested version of me in Poland and wherever I go.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/churchWow.jpeg&quot; alt=&quot;Church&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: justify&quot;&gt; 

&lt;p&gt;During my stay I got to know even more of the city, like several plazas, some parks, churches, a lovely neighborhood next to an island surrounded by two rivers. This would eventually lead to me getting used to Poznan and having the best time I&apos;ve had in more than two years. Poznan is a beautiful city, so much different than cities in Mexico, and I kind of fell in love with it even if it was in such a grey season. Poznan has big old buildings full of history, amazingly wide roadwalks, bycicle roads, a lot of trees, great parks, two beautiful wide rivers, amazing churches, and many other things I didn&apos;t have the time to discover.&lt;/p&gt;

&lt;p&gt;From a western perspective Poles are often described as cold, which is unfair since they&apos;re gentle and hospitable people, and as warm as anyone else in Mexico once you get to know them better. It&apos;s true that they seem to be more introvert than Mexicans, however, I&apos;m an introvert! So I felt just like at home.&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/island.jpeg&quot; alt=&quot;Island&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: justify&quot;&gt; 
&lt;p&gt;I really liked this place, and sadly I had to go back to Mexico. I said goodbye and came back to my dear country after almost 15 days of vacations. My neck and back pains went away, I had rested really well and I kind of forgot how stressed and anxious I could feel on a daily basis. After all, even if I had a bit of a hard time at the beginning, I miss Poland so much, and I want to go back and get to know the rest of the cities I couldn&apos;t visit like Cracow, Wroclaw, Gdansk, Lublin and Warsaw. Whenver I talk about Poland I have this nostalgic feeling and reminisce about good memories. The next time I visit Poland, I might go back during a sunnier weather to be able to stay longer on the outside and see all the beautiful natural landscapes Poland has to offer.&lt;/p&gt;

&lt;p&gt;I recommend visiting Poland a lot, especially if you haven&apos;t been to Europe yet, however, I need to advice you to get to know a bit of the language before going and having a well defined vacation plan. Athough most people speak english, some others don&apos;t, especially older generations. If it&apos;s your first time travelling, be prepared to experience some new feelings, both good and bad. If you&apos;re struggling getting used to a new culture, remember that everything will be OK and we can all adapt to social changes, you&apos;ll eventually grow from the experience.

Do zobaczenia, Polska :)!&lt;/p&gt;
&lt;/div&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">Last December I made my first trip ever to a new country: Poland. This was also my first time taking a flight and my first time taking vacations after I started working as a developer. I decided to go alone on a trip to the city of Poznan, capital of the Greater Poland.</summary></entry><entry><title type="html">Embedding sprites with the aid of Python</title><link href="http://localhost:4000/2019/09/29/sprite-support.html" rel="alternate" type="text/html" title="Embedding sprites with the aid of Python" /><published>2019-09-29T00:00:00-05:00</published><updated>2019-09-29T00:00:00-05:00</updated><id>http://localhost:4000/2019/09/29/sprite-support</id><content type="html" xml:base="http://localhost:4000/2019/09/29/sprite-support.html">&lt;p&gt;After finishing and adding support for my &lt;a href=&quot;https://github.com/Gecko05/SSD1351-Driver-Library&quot;&gt;OLED display library&lt;/a&gt; I decided to move on to the gaming section. This time I would embed sprite support into the library and a way to import sprites into the MCU flash memory, since it can be really tedious to write “by hand” all of the sprites.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/zero.gif&quot; alt=&quot;Zero&quot; class=&quot;img-responsive&quot; width=&quot;600px&quot; caption=&quot;A megaman X animation&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;using-a-sprite&quot;&gt;Using a sprite&lt;/h2&gt;

&lt;p&gt;Well, I don’t quite have the perfect answer for what a sprite is, but I would define a sprite as a 2D image we use as a resource to draw each key frame of every animation and visual effect we’ll see on a screen. With sprites we create an animation, our characters, environment, effects, etc. Basically everything that is visible in a 2D game. Sprites come quite handy to use when working with pixel games, it’s easy to draw them, there are plenty of tools to use and they just look pretty.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spritePixel.jpg&quot; alt=&quot;Sprite sprite&quot; class=&quot;img-responsive&quot; width=&quot;150px&quot; caption=&quot;Sprite sprite&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After reading a bit about image formats I’ve decided to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/BMP_file_format&quot;&gt;.bmp format&lt;/a&gt; to handle sprites, it’s not an optimized format, but it makes image handling way more easy than if we used a compressed format like .png or .jpg.&lt;/p&gt;

&lt;h2 id=&quot;saving-up-space-for-the-sprite&quot;&gt;Saving up space for the sprite&lt;/h2&gt;

&lt;p&gt;Sprites and all kind of images are composed of three basic colors: red, green and blue. Image storage is a challenge, since saving up all three values of these three basic colors for each pixel of your screen could take a heavy amount of memory.&lt;/p&gt;

&lt;p&gt;Let’s say we have a sprite of 128x128 and each pixel has information about the three basic colors with a resolution of 5 bits for red and blue, and 6 bits for green; this means that each pixel would take 16 bits of memory for storage. If we calculate the total amount of memory for this single sprite, we would end up with 128x128x16 bits of memory, which is approximately 262 KB and almost a quarter of the available Flash memory on device!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Palette.png&quot; alt=&quot;Palette&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; caption=&quot;Color palette&quot; align=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortunately, bitmap images have a nice method for storing pixelated images and images with a small amount of colors(up to 256). This aproach consists on making a “palette array” of all the colors used for the image, for this palette we store the real RGB bit value for each palette color. With this palette, the image is just stored as an array of indexes, where each index has a match to a color in the palette array. So, instead of taking 16 bits per pixel, we just take 8 bits, or even less if we’re just using 16 colors(4 bits). This reduces the required storage per image to almost half of what we previously had!&lt;/p&gt;

&lt;h2 id=&quot;creating-a-sprite&quot;&gt;Creating a sprite&lt;/h2&gt;

&lt;p&gt;Now, before creating a sprite inside the SSD1351 library, we need a pixelated image as a reference. Be cautious with the size of the sprite while using this library, it’s not optimized yet so you could deplete the device’s memory. For future releases, a microSD will be used to store all the sprites in order to not take memory from the device.&lt;/p&gt;

&lt;p&gt;Inside the library, a “sprite” is a structure containing a pointer to the actual sprite image as an indexed bitmap, as well as some additional information like the sprite dimensions.
For each sprite an array of unsigned 8-bit integers has to be written, which is a ton of work susceptible for a ton of human errors, right?
This is where machines come in handy and make us dependent to them. A Python script called convertsprites.py will take up all the bitmap images(created with Aseprite) passed as arguments and magically convert them to the aforementioned sprites inside .c files while incredibly reducing the amount of sweat and tears one would spend translating all of these sprites.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/LoadingSprites.png&quot; alt=&quot;Loading a sprite&quot; class=&quot;img-responsive&quot; width=&quot;900px&quot; caption=&quot;Loading a sprite&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the sprites are inside the .c files, one must only compile the project using the library and use the sprites defined in loaded_sprites.c and call those beautiful sprites to be drawn on the screen with the SSD1351_draw_sprite function(It takes a sprite pointer as argument).&lt;/p&gt;

&lt;h2 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h2&gt;

&lt;p&gt;As I mentioned before, for future releases I’ll include a MicroSD card to load all the sprites. Also my SSD1351 library will be used to create a simpler Lua embedded game development interface that allows to write games as if it were Pico8 and maybe someday complete an unofficial port(Although currently TIC80 seems more attractive).
As always feel free to fork and tweak this library, and if you do something with it please let me know, I would love to see it.&lt;/p&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">After finishing and adding support for my OLED display library I decided to move on to the gaming section. This time I would embed sprite support into the library and a way to import sprites into the MCU flash memory, since it can be really tedious to write “by hand” all of the sprites.</summary></entry><entry><title type="html">Using an RGB display with embedded C</title><link href="http://localhost:4000/2019/06/23/rgb-library.html" rel="alternate" type="text/html" title="Using an RGB display with embedded C" /><published>2019-06-23T00:00:00-05:00</published><updated>2019-06-23T00:00:00-05:00</updated><id>http://localhost:4000/2019/06/23/rgb-library</id><content type="html" xml:base="http://localhost:4000/2019/06/23/rgb-library.html">&lt;p&gt;Two months ago I got a new 128x128 OLED Display to play with, this time it was the &lt;strong&gt;SSD1351&lt;/strong&gt;. This OLED display, although limited, supports RGB colors which has been very exciting as it’s my first time working with one of those. I got this display from &lt;a href=&quot;https://www.ebay.com/sch/i.html?_from=R40&amp;amp;_trksid=p2380057.m570.l1313.TR1.TRC0.A0.H0.Xssd1351.TRS0&amp;amp;_nkw=ssd1351&amp;amp;_sacat=0&quot;&gt;ebay&lt;/a&gt; for around $17, a relatively cheap price if we consider its potential.&lt;/p&gt;

&lt;p&gt;For this display I decided to create my own driver library, inspired by the library I used for the &lt;strong&gt;SSD1306&lt;/strong&gt; in the &lt;a href=&quot;https://gecko05.github.io/2019/02/09/nucleo-squashy-part1.html&quot;&gt;previous entry&lt;/a&gt;, with subtle support for printing and graphics display, like rectangles, circles and lines.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssd1351_print.jpg&quot; alt=&quot;Printing demo&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I’ll describe the basics of the development for this library for everyone curious about rudimentary graphics programming. I’m also using the same development board as before, the &lt;strong&gt;Nucleo L152RE&lt;/strong&gt; and &lt;strong&gt;SW4STM32&lt;/strong&gt; as the IDE, however, this library was adjusted to be of generic use in C regardless of the hardware you’re using. Some configuration is needed inside the &lt;em&gt;ssd1351.h&lt;/em&gt; header file though.&lt;/p&gt;

&lt;h1 id=&quot;relevant-hardware-information&quot;&gt;Relevant hardware information&lt;/h1&gt;

&lt;p&gt;As a low level programmer it’s important to look for the data-sheet and specifications of the devices we’re is programming for. So for prototyping, the relevant information we can get from the &lt;a href=&quot;https://www.newhavendisplay.com/app_notes/SSD1351.pdf&quot;&gt;data-sheet&lt;/a&gt; is the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SPI communication(3 or 4 wire)&lt;/li&gt;
  &lt;li&gt;2.4V – 3.5V Power supply&lt;/li&gt;
  &lt;li&gt;128x128x18 SRAM Display Buffer (more on this later)&lt;/li&gt;
  &lt;li&gt;262k color depth&lt;/li&gt;
  &lt;li&gt;Data/Command Pin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssd1351.jpg&quot; alt=&quot;SSD1351&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;start-your-engines&quot;&gt;Start your engines&lt;/h1&gt;

&lt;p&gt;Personally speaking, initialization process is the toughest stage of the development of a driver library, especially if it’s the first time you’re working with the hardware. There’s a lot of information you need to extract from the data-sheet like configuration options, communication modes, working modes, timings, and initialization routines. It’s also the time to create your long list of command and constant definitions, hardware abstraction layer definitions, and more. On top of that, add the excitement of wanting to get your device running as soon as possible and see all that magical stuff you can do with it.&lt;/p&gt;

&lt;p&gt;Once the display turns on and it’s ready to receive data, it’s necessary to unlock the majority of the commands via a special command, then we’re ready to send all the configuration stuff we want to change from the original reset values.&lt;/p&gt;

&lt;h1 id=&quot;communication-is-key&quot;&gt;Communication is key&lt;/h1&gt;

&lt;p&gt;The way to tell the display what to do is based on commands and data transmission. For 3-Wire SPI we only need CS, MOSI and MISO pins as well as an extra pin called C/D to tell the display whether we’re sending a data byte or a command byte. To send a command, the C/D needs to be in logical low and to send data it needs to be in logical high.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/ssd1351_fail.gif&quot; alt=&quot;Color modes&quot; class=&quot;img-responsive&quot; width=&quot;200px&quot; caption=&quot;Oops&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Some commands are followed by one or more bytes of data, and some of them are not, everything is described on the data-sheet. For example, to send the starting and ending row numbers as 0 and 127, we first send the 75h command byte followed by 00h and 7Fh data bytes.
Inside the library, the communication has been abstracted under three “wrapper” functions that every user needs to link to their own HAL. One function is designed to send a command byte, another one to send a data byte and a third one to send a buffer of a specified length.&lt;/p&gt;

&lt;h1 id=&quot;the-display-ram&quot;&gt;The display RAM&lt;/h1&gt;

&lt;p&gt;The display RAM is the most interesting part of the display because it’s where the fun happens. This RAM works as a long array of bytes where each pixel has a total of 18 bits to store the intensity of each color(red, green and blue), so each color is represented by a value of 6 bits. Now, 18 bits is kind of a large number to handle, so to make things easier both in storage and communication, the display offers a variety of color modes. Each color mode has a specified data length to work with, the lower the length the less colors we can use.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/color_modes.png&quot; alt=&quot;Color modes&quot; class=&quot;img-responsive&quot; width=&quot;750px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The best approach to make changes in the display is to perform all the color changes in a local RAM array inside the MCU and, when we’re ready, send the “Write RAM” command followed by all the bytes we’re using to change each pixel’s color. This way we avoid excessive and unnecessary writing to the SPI port which also reduces the time needed to perform complex drawings onto the screen.&lt;/p&gt;

&lt;p&gt;For the library I decided to use the lowest color depth available as it matches quite well the 8-bit SPI communication and it makes byte handling easier. This means we only have to use 5, 6 and 5 bytes for reed, green and blue colors respectively, adding to a total of 2 bytes per pixel. There’s already a function to perform the conversion from rgb values to a single integer of 16 bits.&lt;/p&gt;

&lt;h1 id=&quot;psychedelic-stuff&quot;&gt;Psychedelic stuff&lt;/h1&gt;

&lt;p&gt;With all these tools, we can start writing the fun graphics stuff that involves all the algorithms to draw lines, polygons, circles, and character printing. I gotta admit that other than the rectangles, I didn’t come to these algorithms by my own, there are already optimized algorithms to draw &lt;a href=&quot;https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm&quot;&gt;pixelated lines&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Midpoint_circle_algorithm&quot;&gt;circles&lt;/a&gt;. Currently there are functions to draw individual pixels, draw lines, rectangles, filled rectangles, circles, filled circles, and character printing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/ssd1351_circles.gif&quot; alt=&quot;Circles demo&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The character printing stuff is heavily based on Olivier van Ede’s “ssd1306-stm32HAL”, which is a library for a mono-chromatic OLED display that I used on my previous project. Basically all the fonts files stayed the same except for a few adjustments in readability and generic usage. The formatted printing is a limited feature, it only supports three data types: strings, characters and signed 8-bit integers, as well as the escape character ‘\n’.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/ssd1351_lines.gif&quot; alt=&quot;Lines demo&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;building-upon&quot;&gt;Building upon&lt;/h1&gt;

&lt;p&gt;The next step is going back to the Breakout-like game and develop a way to load sprites from a file system. Then maybe even extending to a graphics library to something more sophisticated as well as importing Lua scripts into a STM32 microcontroller to make simple games that use this library. You can find three demos listed in the main readme file of the repository. As always, if you’re curious then feel free to fork and test this library into your own favorite micro-controller.
&lt;a href=&quot;https://github.com/Gecko05/SSD1351-Driver-Library&quot;&gt;Repository here&lt;/a&gt;&lt;/p&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">Two months ago I got a new 128x128 OLED Display to play with, this time it was the SSD1351. This OLED display, although limited, supports RGB colors which has been very exciting as it’s my first time working with one of those. I got this display from ebay for around $17, a relatively cheap price if we consider its potential.</summary></entry><entry><title type="html">PICO8-like Squashy game in a broken OLED Display</title><link href="http://localhost:4000/2019/02/09/nucleo-squashy-part1.html" rel="alternate" type="text/html" title="PICO8-like Squashy game in a broken OLED Display" /><published>2019-02-09T00:00:00-06:00</published><updated>2019-02-09T00:00:00-06:00</updated><id>http://localhost:4000/2019/02/09/nucleo-squashy-part1</id><content type="html" xml:base="http://localhost:4000/2019/02/09/nucleo-squashy-part1.html">&lt;p&gt;For the first entry of this page I’ll talk about the process of developing a simple Squashy game for one of my favorite ST Boards, the &lt;a href=&quot;https://www.st.com/en/evaluation-tools/nucleo-l152re.html&quot;&gt;Nucleo L152RE&lt;/a&gt;, using &lt;a href=&quot;https://www.freertos.org/&quot;&gt;FreeRTOS&lt;/a&gt;, C language programming and &lt;a href=&quot;https://www.st.com/en/development-tools/sw4stm32.html&quot;&gt;SW4STM32&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The inspiration for this project comes from the very first game example from the &lt;a href=&quot;https://sectordub.itch.io/pico-8-fanzine-1&quot;&gt;PICO-8 Zine  #1&lt;/a&gt; for the &lt;a href=&quot;https://www.lexaloffle.com/pico-8.php&quot;&gt;PICO8&lt;/a&gt; Lua based fantasy console. The first article of the zine guides you through the development of a simple Squashy game, which has pretty much the basic mechanics of a Breakout game.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/squashyPico.png&quot; alt=&quot;Squashy in PICO8&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; image-caption=&quot;Oops&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.lexaloffle.com/bbs/?cat=7&amp;amp;carts_tab=1#sub=2&amp;amp;mode=carts&amp;amp;search=squashy&quot;&gt;game&lt;/a&gt; is pretty straightforward, there’s a ball that bounces between the top, left and right edges of the screen, and a pad which you take control of. The sole objective is to keep bouncing the ball for as long as you can, every time the ball bounces you get +1 in your Score and if the ball touches the bottom of the screen you’ll lose a life.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;
  &lt;iframe src=&quot;https://www.youtube.com/embed/eNKy-4qQbHk&quot; width=&quot;500&quot; height=&quot;290&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;While my first objective was to develop a game for a Nucleo board, I intend to create something resembling a game engine for custom hardware that enables multiplayer options via Bluetooth between one or more console devices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/expected.png&quot; alt=&quot;Expected result&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; caption=&quot;Squashy in PICO8&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;features&quot;&gt;Features&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Speed based controls&lt;/li&gt;
  &lt;li&gt;Can restart the game&lt;/li&gt;
  &lt;li&gt;Score&lt;/li&gt;
  &lt;li&gt;Lives system&lt;/li&gt;
  &lt;li&gt;Bounce beep&lt;/li&gt;
  &lt;li&gt;Bugs&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;whats-missing&quot;&gt;What’s missing&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Good OLED display&lt;/li&gt;
  &lt;li&gt;PWM notes for the buzzer&lt;/li&gt;
  &lt;li&gt;Restart position&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;hardware&quot;&gt;Hardware&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Nucleo L152RE&lt;/li&gt;
  &lt;li&gt;2 Pushbuttons&lt;/li&gt;
  &lt;li&gt;OLED screen SSD1306 with I2C&lt;/li&gt;
  &lt;li&gt;Piezo buzzer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/squashyNucleo.jpg&quot; alt=&quot;Hardware&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For the hardware I’m simply using two push buttons, one piezoelectric buzzer and the cheap mono-color OLED Display SSD1306 which has a screen of 64x128 pixels. However, once I started testing stuff I noticed that my display might be broken because it doesn’t show display other row of pixels. This creates some issues because small sprites of around 6x6 won’t show properly and they might become illegible. Once I get my hands on a new RGB OLED Display I’ll update the project to use a limited palette of 16 colors like the old times.&lt;/p&gt;

&lt;p&gt;I didn’t develop the driver for my SSD1306 from scratch, instead I cloned this simple &lt;a href=&quot;https://github.com/4ilo/ssd1306-stm32HAL&quot;&gt;library&lt;/a&gt; from Olivier Van den Eede which already uses STM32 HAL and contains pretty much all the abstraction I needed to build upon.&lt;/p&gt;

&lt;h1 id=&quot;structure&quot;&gt;Structure&lt;/h1&gt;

&lt;p&gt;First of all, PICO8 games need three fundamental functions; Init, Update and Draw.
Init(), as its name implies, initializes stuff.
Update() is a function that runs continuously in which you execute all calculations related to movement, hits, score, etc.
Draw() is the function that paints all the stuff on the screen.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/picoBasic.png&quot; alt=&quot;Pico8 basic structure&quot; class=&quot;img-responsive&quot; width=&quot;300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/picoInNucleo.png&quot; alt=&quot;Picolike tasks&quot; class=&quot;img-responsive&quot; width=&quot;300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first thing I needed was a system in which I could run both Update and Draw simultaneously, since it’s a more scalable approach than running one function before the other. So taking advantage of the CubeMX tool from STM32 I created a blank project with Middleware FreeRTOS enabled, which is a small Real Time Operating System that can be run on almost any 32-bit Microcontroller.&lt;/p&gt;

&lt;p&gt;As far as I know, any RTOS can work under the concept of preemptive tasks, which are basically looped functions that run “simultaneously”. For this project it means that every time fraction Draw() will do stuff then the program will swap to the Update() function and run for another time fraction, then swap back to Draw() and so on until the end of times(or until the MCU turns off) giving the illusion of running simultaneous tasks.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/preemption.jpg&quot; alt=&quot;Preemptive Tasks&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once I had the project ready I moved on to developing my three main functions. Init() was pretty straightforward, only needed to include initialization of variables, hardware, etc. While Draw() and Update() were independent tasks.&lt;/p&gt;

&lt;p&gt;The basic drawable game element is defined by the structure &lt;em&gt;BodyNode&lt;/em&gt;. &lt;em&gt;BodyNode&lt;/em&gt; contains pretty much all the necessary information to know where every object should be drawn, the details of the sprite it is using and a flag to know whether the program should hide the sprite or not.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spriteHeart.png&quot; alt=&quot;Heart sprite in bits&quot; class=&quot;img-responsive&quot; width=&quot;200px&quot; /&gt;
&lt;img src=&quot;/assets/images/spriteHeartPico.png&quot; alt=&quot;Heart sprite intended&quot; class=&quot;img-responsive&quot; width=&quot;175&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Sprite&lt;/em&gt; type is another structure that holds an array of 16bit unsigned integers(&lt;em&gt;spriteArray&lt;/em&gt;) with the monochromatic pixel information. If a pixel must be drawn then there’s a 1, if not, a 0. It also holds the width and height dimensions in pixels for the sprite so the function that draws every sprite knows how to iterate over the sprite array.&lt;/p&gt;

&lt;p&gt;Feel free to peek around, pretty much every 32bit Nucleo Board could run this game, just set up the peripherals using the STM32CubeMx Tool if you’re not using a L152RE.&lt;/p&gt;

&lt;p&gt;You can find the project’s repository &lt;a href=&quot;https://github.com/Gecko05/NucleoSquashy&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">For the first entry of this page I’ll talk about the process of developing a simple Squashy game for one of my favorite ST Boards, the Nucleo L152RE, using FreeRTOS, C language programming and SW4STM32.</summary></entry></feed>