<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-09-29T09:56:48-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">The Blue Wire</title><subtitle>Here you will find blog entries, tutorials and descriptions of projects about embedded systems programming.</subtitle><entry><title type="html">Embedding sprites with the aid of Python</title><link href="http://localhost:4000/2019/09/29/sprite-support.html" rel="alternate" type="text/html" title="Embedding sprites with the aid of Python" /><published>2019-09-29T00:00:00-05:00</published><updated>2019-09-29T00:00:00-05:00</updated><id>http://localhost:4000/2019/09/29/sprite-support</id><content type="html" xml:base="http://localhost:4000/2019/09/29/sprite-support.html">&lt;p&gt;After finishing and adding support for my &lt;a href=&quot;https://github.com/Gecko05/SSD1351-Driver-Library&quot;&gt;OLED display library&lt;/a&gt; I decided to move on to the gaming section. This time I would embed sprite support into the library and a way to import sprites into the MCU flash memory, since it can be really tedious to write “by hand” all of the sprites.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/zero.gif&quot; alt=&quot;Zero&quot; class=&quot;img-responsive&quot; width=&quot;600px&quot; caption=&quot;A megaman X animation&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;not-that-kind-of-sprite&quot;&gt;Not that kind of sprite&lt;/h2&gt;

&lt;p&gt;Before talking further about games, we need to talk about sprites. Well, I don’t quite have the perfect answer for what a sprite is, but I would define a sprite as a static 2D image we use as a resource to draw all the animations and stuff we’ll see on a screen. With sprites we can define the steps of an animation, our characters, environment, effects, etc. Basically everything that is visible in a 2D game. Sprites come quite handy to use when working with pixel games, it’s easy to draw them, there are plenty of tools to use and they just look pretty.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spritePixel.jpg&quot; alt=&quot;Sprite sprite&quot; class=&quot;img-responsive&quot; width=&quot;150px&quot; caption=&quot;Sprite sprite&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After reading a bit about image formats I’ve decided to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/BMP_file_format&quot;&gt;.bmp format&lt;/a&gt; to handle sprites, it’s not an optimized format, but it makes image handling way more easy than if we used a compressed format like .png or .jpg.&lt;/p&gt;

&lt;h2 id=&quot;saving-up-space-for-the-sprite&quot;&gt;Saving up space for the sprite&lt;/h2&gt;

&lt;p&gt;Sprites and all kind of images are composed of three basic colors: red, green and blue. Image storage is a challenge, since saving up all three values of these three basic colors for each pixel of your screen could take a heavy amount of memory.&lt;/p&gt;

&lt;p&gt;Let’s say we have a sprite of 128x128 and each pixel has information about the three basic colors with a resolution of 5 bits for red and blue, and 6 bits for green; this means that each pixel would take 16 bits of memory for storage. If we calculate the total amount of memory for this single sprite, we would end up with 128x128x16 bits of memory, which is approximately 262 KB and almost a quarter of the available Flash memory on device!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Palette.png&quot; alt=&quot;Palette&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; caption=&quot;Color palette&quot; align=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortunately, bitmap images have a nice method for storing pixelated images and images with a small amount of colors(up to 256). This aproach consists on making a “palette array” of all the colors used for the image, for this palette we store the real RGB bit value for each palette color. With this palette, the image is just stored as an array of indexes, where each index has a match to a color in the palette array. So, instead of taking 16 bits per pixel, we just take 8 bits, or even less if we’re just using 16 colors(4 bits). This reduces the required storage per image to almost half of what we previously had!&lt;/p&gt;

&lt;h2 id=&quot;creating-a-sprite&quot;&gt;Creating a sprite&lt;/h2&gt;

&lt;p&gt;Now, before creating a sprite inside the SSD1351 library, we need a pixelated image as a reference. Be cautious with the size of the sprite while using this library, it’s not optimized yet so you could deplete the device’s memory. For future releases, a microSD will be used to store all the sprites in order to not take memory from the device.&lt;/p&gt;

&lt;p&gt;Inside the library, a “sprite” is a structure containing a pointer to the actual sprite image as an indexed bitmap, as well as some additional information like the sprite dimensions.
For each sprite an array of unsigned 8-bit integers has to be written, which is a ton of work susceptible for a ton of human errors, right?
This is where machines come in handy and make us dependent to them. A Python script called convertsprites.py will take up all the bitmap images(created with Aseprite) passed as arguments and magically convert them to the aforementioned sprites inside .c files while incredibly reducing the amount of sweat and tears one would spend translating all of these sprites.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/LoadingSprites.png&quot; alt=&quot;Loading a sprite&quot; class=&quot;img-responsive&quot; width=&quot;900px&quot; caption=&quot;Loading a sprite&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the sprites are inside the .c files, one must only compile the project using the library and use the sprites defined in loaded_sprites.c and call those beautiful sprites to be drawn on the screen with the SSD1351_draw_sprite function(It takes a sprite pointer as argument).&lt;/p&gt;

&lt;h2 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h2&gt;

&lt;p&gt;As I mentioned before, for future releases I’ll include a MicroSD card to load all the sprites. Also my SSD1351 library will be used to create a simpler Lua embedded game development interface that allows to write games as if it were Pico8 and maybe someday complete an unofficial port(Although currently TIC80 seems more attractive).
As always feel free to fork and tweak this library, and if you do something with it please let me know, I would love to see it.&lt;/p&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">After finishing and adding support for my OLED display library I decided to move on to the gaming section. This time I would embed sprite support into the library and a way to import sprites into the MCU flash memory, since it can be really tedious to write “by hand” all of the sprites.</summary></entry><entry><title type="html">Using an RGB display with embedded C</title><link href="http://localhost:4000/2019/06/23/rgb-library.html" rel="alternate" type="text/html" title="Using an RGB display with embedded C" /><published>2019-06-23T00:00:00-05:00</published><updated>2019-06-23T00:00:00-05:00</updated><id>http://localhost:4000/2019/06/23/rgb-library</id><content type="html" xml:base="http://localhost:4000/2019/06/23/rgb-library.html">&lt;p&gt;Two months ago I got a new 128x128 OLED Display to play with, this time it was the &lt;strong&gt;SSD1351&lt;/strong&gt;. This OLED display, although limited, supports RGB colors which has been very exciting as it’s my first time working with one of those. I got this display from &lt;a href=&quot;https://www.ebay.com/sch/i.html?_from=R40&amp;amp;_trksid=p2380057.m570.l1313.TR1.TRC0.A0.H0.Xssd1351.TRS0&amp;amp;_nkw=ssd1351&amp;amp;_sacat=0&quot;&gt;ebay&lt;/a&gt; for around $17, a relatively cheap price if we consider its potential.&lt;/p&gt;

&lt;p&gt;For this display I decided to create my own driver library, inspired by the library I used for the &lt;strong&gt;SSD1306&lt;/strong&gt; in the &lt;a href=&quot;https://gecko05.github.io/2019/02/09/nucleo-squashy-part1.html&quot;&gt;previous entry&lt;/a&gt;, with subtle support for printing and graphics display, like rectangles, circles and lines.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssd1351_print.jpg&quot; alt=&quot;Printing demo&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I’ll describe the basics of the development for this library for everyone curious about rudimentary graphics programming. I’m also using the same development board as before, the &lt;strong&gt;Nucleo L152RE&lt;/strong&gt; and &lt;strong&gt;SW4STM32&lt;/strong&gt; as the IDE, however, this library was adjusted to be of generic use in C regardless of the hardware you’re using. Some configuration is needed inside the &lt;em&gt;ssd1351.h&lt;/em&gt; header file though.&lt;/p&gt;

&lt;h1 id=&quot;relevant-hardware-information&quot;&gt;Relevant hardware information&lt;/h1&gt;

&lt;p&gt;As a low level programmer it’s important to look for the data-sheet and specifications of the devices we’re is programming for. So for prototyping, the relevant information we can get from the &lt;a href=&quot;https://www.newhavendisplay.com/app_notes/SSD1351.pdf&quot;&gt;data-sheet&lt;/a&gt; is the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SPI communication(3 or 4 wire)&lt;/li&gt;
  &lt;li&gt;2.4V – 3.5V Power supply&lt;/li&gt;
  &lt;li&gt;128x128x18 SRAM Display Buffer (more on this later)&lt;/li&gt;
  &lt;li&gt;262k color depth&lt;/li&gt;
  &lt;li&gt;Data/Command Pin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssd1351.jpg&quot; alt=&quot;SSD1351&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;start-your-engines&quot;&gt;Start your engines&lt;/h1&gt;

&lt;p&gt;Personally speaking, initialization process is the toughest stage of the development of a driver library, especially if it’s the first time you’re working with the hardware. There’s a lot of information you need to extract from the data-sheet like configuration options, communication modes, working modes, timings, and initialization routines. It’s also the time to create your long list of command and constant definitions, hardware abstraction layer definitions, and more. On top of that, add the excitement of wanting to get your device running as soon as possible and see all that magical stuff you can do with it.&lt;/p&gt;

&lt;p&gt;Once the display turns on and it’s ready to receive data, it’s necessary to unlock the majority of the commands via a special command, then we’re ready to send all the configuration stuff we want to change from the original reset values.&lt;/p&gt;

&lt;h1 id=&quot;communication-is-key&quot;&gt;Communication is key&lt;/h1&gt;

&lt;p&gt;The way to tell the display what to do is based on commands and data transmission. For 3-Wire SPI we only need CS, MOSI and MISO pins as well as an extra pin called C/D to tell the display whether we’re sending a data byte or a command byte. To send a command, the C/D needs to be in logical low and to send data it needs to be in logical high.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/ssd1351_fail.gif&quot; alt=&quot;Color modes&quot; class=&quot;img-responsive&quot; width=&quot;200px&quot; caption=&quot;Oops&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Some commands are followed by one or more bytes of data, and some of them are not, everything is described on the data-sheet. For example, to send the starting and ending row numbers as 0 and 127, we first send the 75h command byte followed by 00h and 7Fh data bytes.
Inside the library, the communication has been abstracted under three “wrapper” functions that every user needs to link to their own HAL. One function is designed to send a command byte, another one to send a data byte and a third one to send a buffer of a specified length.&lt;/p&gt;

&lt;h1 id=&quot;the-display-ram&quot;&gt;The display RAM&lt;/h1&gt;

&lt;p&gt;The display RAM is the most interesting part of the display because it’s where the fun happens. This RAM works as a long array of bytes where each pixel has a total of 18 bits to store the intensity of each color(red, green and blue), so each color is represented by a value of 6 bits. Now, 18 bits is kind of a large number to handle, so to make things easier both in storage and communication, the display offers a variety of color modes. Each color mode has a specified data length to work with, the lower the length the less colors we can use.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/color_modes.png&quot; alt=&quot;Color modes&quot; class=&quot;img-responsive&quot; width=&quot;750px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The best approach to make changes in the display is to perform all the color changes in a local RAM array inside the MCU and, when we’re ready, send the “Write RAM” command followed by all the bytes we’re using to change each pixel’s color. This way we avoid excessive and unnecessary writing to the SPI port which also reduces the time needed to perform complex drawings onto the screen.&lt;/p&gt;

&lt;p&gt;For the library I decided to use the lowest color depth available as it matches quite well the 8-bit SPI communication and it makes byte handling easier. This means we only have to use 5, 6 and 5 bytes for reed, green and blue colors respectively, adding to a total of 2 bytes per pixel. There’s already a function to perform the conversion from rgb values to a single integer of 16 bits.&lt;/p&gt;

&lt;h1 id=&quot;psychedelic-stuff&quot;&gt;Psychedelic stuff&lt;/h1&gt;

&lt;p&gt;With all these tools, we can start writing the fun graphics stuff that involves all the algorithms to draw lines, polygons, circles, and character printing. I gotta admit that other than the rectangles, I didn’t come to these algorithms by my own, there are already optimized algorithms to draw &lt;a href=&quot;https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm&quot;&gt;pixelated lines&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Midpoint_circle_algorithm&quot;&gt;circles&lt;/a&gt;. Currently there are functions to draw individual pixels, draw lines, rectangles, filled rectangles, circles, filled circles, and character printing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/ssd1351_circles.gif&quot; alt=&quot;Circles demo&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The character printing stuff is heavily based on Olivier van Ede’s “ssd1306-stm32HAL”, which is a library for a mono-chromatic OLED display that I used on my previous project. Basically all the fonts files stayed the same except for a few adjustments in readability and generic usage. The formatted printing is a limited feature, it only supports three data types: strings, characters and signed 8-bit integers, as well as the escape character ‘\n’.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gifs/ssd1351_lines.gif&quot; alt=&quot;Lines demo&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;building-upon&quot;&gt;Building upon&lt;/h1&gt;

&lt;p&gt;The next step is going back to the Breakout-like game and develop a way to load sprites from a file system. Then maybe even extending to a graphics library to something more sophisticated as well as importing Lua scripts into a STM32 microcontroller to make simple games that use this library. You can find three demos listed in the main readme file of the repository. As always, if you’re curious then feel free to fork and test this library into your own favorite micro-controller.&lt;/p&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">Two months ago I got a new 128x128 OLED Display to play with, this time it was the SSD1351. This OLED display, although limited, supports RGB colors which has been very exciting as it’s my first time working with one of those. I got this display from ebay for around $17, a relatively cheap price if we consider its potential.</summary></entry><entry><title type="html">PICO8-like Squashy game in a broken OLED Display</title><link href="http://localhost:4000/2019/02/09/nucleo-squashy-part1.html" rel="alternate" type="text/html" title="PICO8-like Squashy game in a broken OLED Display" /><published>2019-02-09T00:00:00-06:00</published><updated>2019-02-09T00:00:00-06:00</updated><id>http://localhost:4000/2019/02/09/nucleo-squashy-part1</id><content type="html" xml:base="http://localhost:4000/2019/02/09/nucleo-squashy-part1.html">&lt;p&gt;For the first entry of this page I’ll talk about the process of developing a simple Squashy game for one of my favorite ST Boards, the &lt;a href=&quot;https://www.st.com/en/evaluation-tools/nucleo-l152re.html&quot;&gt;Nucleo L152RE&lt;/a&gt;, using &lt;a href=&quot;https://www.freertos.org/&quot;&gt;FreeRTOS&lt;/a&gt;, C language programming and &lt;a href=&quot;https://www.st.com/en/development-tools/sw4stm32.html&quot;&gt;SW4STM32&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The inspiration for this project comes from the very first game example from the &lt;a href=&quot;https://sectordub.itch.io/pico-8-fanzine-1&quot;&gt;PICO-8 Zine  #1&lt;/a&gt; for the &lt;a href=&quot;https://www.lexaloffle.com/pico-8.php&quot;&gt;PICO8&lt;/a&gt; Lua based fantasy console. The first article of the zine guides you through the development of a simple Squashy game, which has pretty much the basic mechanics of a Breakout game.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/squashyPico.png&quot; alt=&quot;Squashy in PICO8&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; image-caption=&quot;Oops&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://www.lexaloffle.com/bbs/?cat=7&amp;amp;carts_tab=1#sub=2&amp;amp;mode=carts&amp;amp;search=squashy&quot;&gt;game&lt;/a&gt; is pretty straightforward, there’s a ball that bounces between the top, left and right edges of the screen, and a pad which you take control of. The sole objective is to keep bouncing the ball for as long as you can, every time the ball bounces you get +1 in your Score and if the ball touches the bottom of the screen you’ll lose a life.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;
  &lt;iframe src=&quot;https://www.youtube.com/embed/eNKy-4qQbHk&quot; width=&quot;500&quot; height=&quot;290&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;While my first objective was to develop a game for a Nucleo board, I intend to create something resembling a game engine for custom hardware that enables multiplayer options via Bluetooth between one or more console devices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/expected.png&quot; alt=&quot;Expected result&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; caption=&quot;Squashy in PICO8&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;features&quot;&gt;Features&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Speed based controls&lt;/li&gt;
  &lt;li&gt;Can restart the game&lt;/li&gt;
  &lt;li&gt;Score&lt;/li&gt;
  &lt;li&gt;Lives system&lt;/li&gt;
  &lt;li&gt;Bounce beep&lt;/li&gt;
  &lt;li&gt;Bugs&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;whats-missing&quot;&gt;What’s missing&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Good OLED display&lt;/li&gt;
  &lt;li&gt;PWM notes for the buzzer&lt;/li&gt;
  &lt;li&gt;Restart position&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;hardware&quot;&gt;Hardware&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Nucleo L152RE&lt;/li&gt;
  &lt;li&gt;2 Pushbuttons&lt;/li&gt;
  &lt;li&gt;OLED screen SSD1306 with I2C&lt;/li&gt;
  &lt;li&gt;Piezo buzzer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/squashyNucleo.jpg&quot; alt=&quot;Hardware&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For the hardware I’m simply using two push buttons, one piezoelectric buzzer and the cheap mono-color OLED Display SSD1306 which has a screen of 64x128 pixels. However, once I started testing stuff I noticed that my display might be broken because it doesn’t show display other row of pixels. This creates some issues because small sprites of around 6x6 won’t show properly and they might become illegible. Once I get my hands on a new RGB OLED Display I’ll update the project to use a limited palette of 16 colors like the old times.&lt;/p&gt;

&lt;p&gt;I didn’t develop the driver for my SSD1306 from scratch, instead I cloned this simple &lt;a href=&quot;https://github.com/4ilo/ssd1306-stm32HAL&quot;&gt;library&lt;/a&gt; from Olivier Van den Eede which already uses STM32 HAL and contains pretty much all the abstraction I needed to build upon.&lt;/p&gt;

&lt;h1 id=&quot;structure&quot;&gt;Structure&lt;/h1&gt;

&lt;p&gt;First of all, PICO8 games need three fundamental functions; Init, Update and Draw.
Init(), as its name implies, initializes stuff.
Update() is a function that runs continuously in which you execute all calculations related to movement, hits, score, etc.
Draw() is the function that paints all the stuff on the screen.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/picoBasic.png&quot; alt=&quot;Pico8 basic structure&quot; class=&quot;img-responsive&quot; width=&quot;300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/picoInNucleo.png&quot; alt=&quot;Picolike tasks&quot; class=&quot;img-responsive&quot; width=&quot;300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first thing I needed was a system in which I could run both Update and Draw simultaneously, since it’s a more scalable approach than running one function before the other. So taking advantage of the CubeMX tool from STM32 I created a blank project with Middleware FreeRTOS enabled, which is a small Real Time Operating System that can be run on almost any 32-bit Microcontroller.&lt;/p&gt;

&lt;p&gt;As far as I know, any RTOS can work under the concept of preemptive tasks, which are basically looped functions that run “simultaneously”. For this project it means that every time fraction Draw() will do stuff then the program will swap to the Update() function and run for another time fraction, then swap back to Draw() and so on until the end of times(or until the MCU turns off) giving the illusion of running simultaneous tasks.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/preemption.jpg&quot; alt=&quot;Preemptive Tasks&quot; class=&quot;img-responsive&quot; width=&quot;400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once I had the project ready I moved on to developing my three main functions. Init() was pretty straightforward, only needed to include initialization of variables, hardware, etc. While Draw() and Update() were independent tasks.&lt;/p&gt;

&lt;p&gt;The basic drawable game element is defined by the structure &lt;em&gt;BodyNode&lt;/em&gt;. &lt;em&gt;BodyNode&lt;/em&gt; contains pretty much all the necessary information to know where every object should be drawn, the details of the sprite it is using and a flag to know whether the program should hide the sprite or not.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spriteHeart.png&quot; alt=&quot;Heart sprite in bits&quot; class=&quot;img-responsive&quot; width=&quot;200px&quot; /&gt;
&lt;img src=&quot;/assets/images/spriteHeartPico.png&quot; alt=&quot;Heart sprite intended&quot; class=&quot;img-responsive&quot; width=&quot;175&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Sprite&lt;/em&gt; type is another structure that holds an array of 16bit unsigned integers(&lt;em&gt;spriteArray&lt;/em&gt;) with the monochromatic pixel information. If a pixel must be drawn then there’s a 1, if not, a 0. It also holds the width and height dimensions in pixels for the sprite so the function that draws every sprite knows how to iterate over the sprite array.&lt;/p&gt;

&lt;p&gt;Feel free to peek around, pretty much every 32bit Nucleo Board could run this game, just set up the peripherals using the STM32CubeMx Tool if you’re not using a L152RE.&lt;/p&gt;

&lt;p&gt;You can find the project’s repository &lt;a href=&quot;https://github.com/Gecko05/NucleoSquashy&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Jaime Centeno</name></author><summary type="html">For the first entry of this page I’ll talk about the process of developing a simple Squashy game for one of my favorite ST Boards, the Nucleo L152RE, using FreeRTOS, C language programming and SW4STM32.</summary></entry></feed>